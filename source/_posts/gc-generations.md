---
title: GC算法梳理（六）堆分区与分代垃圾回收
date: 2019-08-15 14:48:07
categories: 技术笔记
tags: GC
---

前几篇笔记介绍了几种基本的垃圾回收算法，那么是不是堆上所有的对象都是由相同的垃圾算法管理的呢？而且所有的垃圾都是在同一时间得到回收的呢？答案自然是否定的。
事实上，根据不同对象的存活特性，如果我们针对性地处理不同的对象的话，对垃圾回收的性能提升是非常有效的。目前应用最广泛的例子就是 —— **分代垃圾回收 (Generational garbage collection)**。分代垃圾回收的基本思想就是根据对象的年龄进行分隔，优先回收更年轻的对象。

接下来，我们稍微深入地聊一聊堆分区与分代垃圾回收那些事吧~
<!--more-->
---
# 为什么要进行分区
将堆分割成多个分区，每个分区采用不同的管理策略通常能更好地利用结合对象的移动性、大小和类别等性质，获得更低的空间消耗、更简单的对象性质识别、改善垃圾回收效率、降低停顿时间、更好的局部性等。

1. **移动性与分区**
对于一个混合回收器，识别哪些对象可移动、哪些对象不可移动或移动代价很大是十分必要的。对于移动式 GC，必须找到所有指向这个对象的引用；相反，如果是非移动式 GC，则只需要找到至少一个引用就够了。而当一个引用被传给一个根本不关心垃圾回收的程序库时，这个对象就不能被移动了。此时，要么这个对象被钉住不动，要么我们要保证在程序库访问期间不能在其所处空间执行垃圾回收。

2. **对象大小与分区**
移动大对象的代价可能比不移动而放弃消除碎片的代价大。因此，一个常用策略是将大小超过一定阈值的对象分配到一个专门的**大对象空间 (Large object space, LOS)** 中去，并使用像**标记-清除**这样的非移动式 GC 进行管理。（通常不会采用复制式 GC 回收大对象，因为为对象预留复制空间代价高昂。）

3. **对象生命周期与分区**
对于生命周期长且内存碎片对其并非急需处理的对象来说，可以将其保存在一个采用非移动 GC，偶尔会进行一趟扫描进行整理的空间；对于分配频率高、生命周期短、死亡率更高的对象则可以放到一个由份额皮速度快、回收代价小的复制式 GC 管理的空间中去。

4. **对象类别与分区**
将不同类别的对象进行物理隔离可以让“**类型**”这样的属性通过对象地址就可以识别，而无需读取对象的某一字段。这样做将所有共享相同属性的对象放在同一空间中，避免了在每个对象头部复制一套重复的属性。

5. **对象用途与分区**
回收器可能会根据对象的物理分布采取不同的处理策略。有研究者提出，在一个应用程序服务器中，作为客户端请求的一部分而初始化的远程对象往往比本地对象存活的时间长。通常，在一个采用分布式 GC 管理的系统中，最好能使用不同的策略管理远程和本地的对象和引用，因为访问远程对象的代价比本地大几个数量级。

6. **对象易变性与分区**
相对于存活时间较长的对象，新创建的对象往往被修改得更频繁，因此引用计数法就不太适用于这类频繁更新的对象。

---
# 何时进行分区
分区的决策既可以是静态 (编译器) 完成，可以动态进行。
* **静态分区** - 通过对对象的类型、代码或者其他信息的分析，对象所属空间可以被静态的划定。（比如编译器预分配）

* **动态分区**
    * **在对象被创建时** - 分配器会根据对象所需要的内存大小来决定对象是否要被分配到大对象空间中。
    * **在垃圾回收期间** - 例如在分代垃圾回收中，分区是由回收器动态执行的，当一个对象的年龄增长超过某个阈值的时候，这个对象就被从物理上或逻辑上移动到下一个分代的空间中。
    * **当赋值器访问对象时** - 在并发回收器中，赋值器访问对象的操作可能会被读屏障或写屏障居中调节，从而导致一个或多个对象被移动或标记。

---
# 分代垃圾回收
分代垃圾回收的出现基于根据经验后得出的一条结论 —— **大多数对象都在年轻时死亡**，又被称为“**弱分代假说 (Weak generational hypothesis)**”。这一假说已在各种不同种类的编程范式和编程语言中得到证实。（事实证明，它们就是轻易地 go die 了，⊙︿⊙

---
## 新生代与老年代
分代垃圾回收按照对象的年龄 (age) 将其划分为不同的分代，同时将不同分代的对象置于堆中的不停区域。回收器会优先回收年轻代，对象的年龄随从垃圾回收中存活的次数递增，当年轻代中的对象年龄达到一定阈值，将被提升 (promote) 到更老的一代。

**一些术语**
* **新生代 GC (Minor GC)** - 在新生代中执行的 GC
* **对象提升 (Promotion)** - 将新生代中的对象提升为老年代对象的过程
* **老年代 GC (Major GC)** - 在老年代中执行的 GC

下面我们将介绍由 David Ungar 于 1984 年在文章 *Generation Scavenging: A Non-disruptlve High Perfornm.nce
Storage Reclamation Algorithm* 中提出的分代回收算法。
---
## Ungar 的分代垃圾回收
Ungar 提出的分代垃圾回收将堆分为4个空间，三个用于新生代，一个用于老年代，它们分别是：
* NewSpace - 用于创建对象的空间，也就是进行分配的空间
* PastSurvivorSpace - 保存上一次 Minor GC 后存活的对象，相当于复制 GC 中的 From 空间
* FutureSurvivorSpace - 一个空的空间，相当于复制 GC 中的 To 空间
* OldSpace - 存放老年代对象的空间

NewSpace 通常是 SurvivorSpace 的 N 倍，根据弱分代假说，绝大多数 NewSpace 中的对象都会死亡，因此这样分配空间有利于提高堆空间利用率。

执行新生代 GC 会将 NewSpace 和 PastSurvivorSpace 中的活动对象复制到 FutureSurvivorSpace 中，然后清除这两个空间，最后将 PastSurvivorSpace 和 FutureSurvivorSpace交换，跟复制 GC 是一样的。

这一过程中，如果发现新生代对象已经经历了一定次数的新生代 GC，它就会得到晋升，被复制到老年代中去。（小菜鸟变身老油条啦~ (ノ￣▽￣)

如果老年代空间也满了，那就要执行老年代 GC。老年代 GC 可以采用标记-清除算法。

---
### Remembered Set 记录集
