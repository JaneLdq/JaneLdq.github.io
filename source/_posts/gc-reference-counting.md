---
title: GC算法梳理（二）引用计数器
date: 2019-07-24 08:08:54
categories: 技术笔记
tags: GC
---

什么是垃圾？不可能再被任何途径使用的对象。

由此很容易想到采用**引用计数**的方法：让对象记录下**有多少其他对象引用自己**。当引用数为0时，对象就被该作为垃圾回收了。（过气网红即视感ಠ_ಠ
<!--more-->

# 引用计数器
引用计数器的基本实现很简单，它不像标记-清除算法那样有明确的 GC 操作，而是在**创建对象时**和**对指针进行更新时**同时完成引用计数器的更新。

我们来看一下引用计数器算法的伪码：
```c++
// 创建对象时，将其引用计数赋值为1
new_obj(size) {
    obj = pickup_chunk(size, $free_list)
    if (obj == NULL) {
        allocation_fail()
    } else {
        obj.ref_cnt = 1
        return obj
    }
}

// 将对象赋值给一个指针时，将指针原来引用的对象的引用计数减一
update_ptr(ptr, obj) {
    // 对指针 ptr 新引用的对象的引用计数器加一（小P: 新墙头～我来了～
    inc_ref_cnt(obj)
    // 对指针 ptr 之前指向的对象的引用计数器减一（小P: 对不起，你失去本指针了
    dec_ref_cnt(*ptr)
    *ptr = obj
}
```

计数器增减操作：
```c++
// 引用计数器加一操作
inc_ref_cnt(obj) {
    obj.ref_cnt++
}

// 引用计数器减一操作
dec_ref_cnt(obj) {
    obj.ref_cnt--
    // 如果 obj 的引用数为0，那么它就要被回收了，所有被它引用的对象的引用计数器也要递减
    if (obj.ref_cnt == 0) {
        for (child: obj.children) {
            dec_ref_cnt(child)
        }
        // 回收 obj，将 obj 连接到空闲链表
        reclaim(obj)
    }
}
```

那么问题来了，**为什么在更新指针时要先增后减呢？先减后增不是一样的吗？**
还真不一样哦，**考虑 `*ptr` 和 `obj` 是同一对象时的情况**。如果先减后增，而 `obj` 的引用计数在减一之后为 0 的话，它就直接被回收了，再执行`inc_ref_cnt`就要出错了。反过来，先增后减的话就可以避免这种情况发生。

通过更新指针，可能会产生没有被其他任何地方引用的“垃圾”，引用计数法会在指针更新时监督是否有垃圾产生，从而在垃圾产生时将其立刻回收。同时这也意味着，在为新对象申请空间时如果没有分块，就没法新分配对象，因为堆中所有的对象都为活动对象。

---
# 优缺点

先说优点：
* **可即刻回收垃圾** - 当对象的被引用数变为 0 的那一刻，它就明白自己已经是个垃圾了，然后它就会非常自觉地把自己作为空闲空间连接到空闲链表中去。
* **暂停时间短** - 垃圾回收在每次指针变更时都会进行，因此单次垃圾回收量并不大，时间自然更短
* **不用沿指针查找** - 在需要减少沿指针查找的次数时，引用计数法就有优势了。（举个例子，在分布式环境中如果要沿节点之间的指针进行查找，成本就会很高。）

// 未完待续～






